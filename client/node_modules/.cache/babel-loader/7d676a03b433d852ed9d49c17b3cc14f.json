{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NetworkEventManager = void 0;\n/**\n * @internal\n *\n * Helper class to track network events by request ID\n */\n\nclass NetworkEventManager {\n  constructor() {\n    /*\n     * There are four possible orders of events:\n     *  A. `_onRequestWillBeSent`\n     *  B. `_onRequestWillBeSent`, `_onRequestPaused`\n     *  C. `_onRequestPaused`, `_onRequestWillBeSent`\n     *  D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`\n     *     (see crbug.com/1196004)\n     *\n     * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n     * optionally the `interceptionId` from `_onRequestPaused`.\n     *\n     * If request interception is disabled, call `_onRequest` once per call to\n     * `_onRequestWillBeSent`.\n     * If request interception is enabled, call `_onRequest` once per call to\n     * `_onRequestPaused` (once per `interceptionId`).\n     *\n     * Events are stored to allow for subsequent events to call `_onRequest`.\n     *\n     * Note that (chains of) redirect requests have the same `requestId` (!) as\n     * the original request. We have to anticipate series of events like these:\n     *  A. `_onRequestWillBeSent`,\n     *     `_onRequestWillBeSent`, ...\n     *  B. `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestWillBeSent`, `_onRequestPaused`, ...\n     *  C. `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestPaused`, `_onRequestWillBeSent`, ...\n     *  D. `_onRequestPaused`, `_onRequestWillBeSent`,\n     *     `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...\n     *     (see crbug.com/1196004)\n     */\n    this._requestWillBeSentMap = new Map();\n    this._requestPausedMap = new Map();\n    this._httpRequestsMap = new Map();\n    /*\n     * The below maps are used to reconcile Network.responseReceivedExtraInfo\n     * events with their corresponding request. Each response and redirect\n     * response gets an ExtraInfo event, and we don't know which will come first.\n     * This means that we have to store a Response or an ExtraInfo for each\n     * response, and emit the event when we get both of them. In addition, to\n     * handle redirects, we have to make them Arrays to represent the chain of\n     * events.\n     */\n\n    this._responseReceivedExtraInfoMap = new Map();\n    this._queuedRedirectInfoMap = new Map();\n    this._queuedEventGroupMap = new Map();\n  }\n\n  forget(networkRequestId) {\n    this._requestWillBeSentMap.delete(networkRequestId);\n\n    this._requestPausedMap.delete(networkRequestId);\n\n    this._queuedEventGroupMap.delete(networkRequestId);\n\n    this._queuedRedirectInfoMap.delete(networkRequestId);\n\n    this._responseReceivedExtraInfoMap.delete(networkRequestId);\n  }\n\n  responseExtraInfo(networkRequestId) {\n    if (!this._responseReceivedExtraInfoMap.has(networkRequestId)) {\n      this._responseReceivedExtraInfoMap.set(networkRequestId, []);\n    }\n\n    return this._responseReceivedExtraInfoMap.get(networkRequestId);\n  }\n\n  queuedRedirectInfo(fetchRequestId) {\n    if (!this._queuedRedirectInfoMap.has(fetchRequestId)) {\n      this._queuedRedirectInfoMap.set(fetchRequestId, []);\n    }\n\n    return this._queuedRedirectInfoMap.get(fetchRequestId);\n  }\n\n  queueRedirectInfo(fetchRequestId, redirectInfo) {\n    this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);\n  }\n\n  takeQueuedRedirectInfo(fetchRequestId) {\n    return this.queuedRedirectInfo(fetchRequestId).shift();\n  }\n\n  numRequestsInProgress() {\n    return [...this._httpRequestsMap].filter(_ref => {\n      let [, request] = _ref;\n      return !request.response();\n    }).length;\n  }\n\n  storeRequestWillBeSent(networkRequestId, event) {\n    this._requestWillBeSentMap.set(networkRequestId, event);\n  }\n\n  getRequestWillBeSent(networkRequestId) {\n    return this._requestWillBeSentMap.get(networkRequestId);\n  }\n\n  forgetRequestWillBeSent(networkRequestId) {\n    this._requestPausedMap.delete(networkRequestId);\n  }\n\n  getRequestPaused(networkRequestId) {\n    return this._requestPausedMap.get(networkRequestId);\n  }\n\n  forgetRequestPaused(networkRequestId) {\n    this._requestPausedMap.delete(networkRequestId);\n  }\n\n  storeRequestPaused(networkRequestId, event) {\n    this._requestPausedMap.set(networkRequestId, event);\n  }\n\n  getRequest(networkRequestId) {\n    return this._httpRequestsMap.get(networkRequestId);\n  }\n\n  storeRequest(networkRequestId, request) {\n    this._httpRequestsMap.set(networkRequestId, request);\n  }\n\n  forgetRequest(networkRequestId) {\n    this._httpRequestsMap.delete(networkRequestId);\n  }\n\n  getQueuedEventGroup(networkRequestId) {\n    return this._queuedEventGroupMap.get(networkRequestId);\n  }\n\n  queueEventGroup(networkRequestId, event) {\n    this._queuedEventGroupMap.set(networkRequestId, event);\n  }\n\n}\n\nexports.NetworkEventManager = NetworkEventManager;","map":{"version":3,"mappings":"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","names":["NetworkEventManager","constructor","Map","forget","networkRequestId","_requestWillBeSentMap","delete","_requestPausedMap","_queuedEventGroupMap","_queuedRedirectInfoMap","_responseReceivedExtraInfoMap","responseExtraInfo","has","set","get","queuedRedirectInfo","fetchRequestId","queueRedirectInfo","redirectInfo","push","takeQueuedRedirectInfo","shift","numRequestsInProgress","_httpRequestsMap","filter","request","response","length","storeRequestWillBeSent","event","getRequestWillBeSent","forgetRequestWillBeSent","getRequestPaused","forgetRequestPaused","storeRequestPaused","getRequest","storeRequest","forgetRequest","getQueuedEventGroup","queueEventGroup","exports"],"sources":["../../../../src/common/NetworkEventManager.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}