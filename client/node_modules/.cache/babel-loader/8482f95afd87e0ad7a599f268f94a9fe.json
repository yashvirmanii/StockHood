{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HTTPResponse = void 0;\n\nconst SecurityDetails_js_1 = require(\"./SecurityDetails.js\");\n\nconst Errors_js_1 = require(\"./Errors.js\");\n/**\n * The HTTPResponse class represents responses which are received by the\n * {@link Page} class.\n *\n * @public\n */\n\n\nclass HTTPResponse {\n  /**\n   * @internal\n   */\n  constructor(client, request, responsePayload, extraInfo) {\n    this._contentPromise = null;\n    this._headers = {};\n    this._client = client;\n    this._request = request;\n    this._bodyLoadedPromise = new Promise(fulfill => {\n      this._bodyLoadedPromiseFulfill = fulfill;\n    });\n    this._remoteAddress = {\n      ip: responsePayload.remoteIPAddress,\n      port: responsePayload.remotePort\n    };\n    this._statusText = this._parseStatusTextFromExtrInfo(extraInfo) || responsePayload.statusText;\n    this._url = request.url();\n    this._fromDiskCache = !!responsePayload.fromDiskCache;\n    this._fromServiceWorker = !!responsePayload.fromServiceWorker;\n    this._status = extraInfo ? extraInfo.statusCode : responsePayload.status;\n    const headers = extraInfo ? extraInfo.headers : responsePayload.headers;\n\n    for (const key of Object.keys(headers)) this._headers[key.toLowerCase()] = headers[key];\n\n    this._securityDetails = responsePayload.securityDetails ? new SecurityDetails_js_1.SecurityDetails(responsePayload.securityDetails) : null;\n    this._timing = responsePayload.timing;\n  }\n  /**\n   * @internal\n   */\n\n\n  _parseStatusTextFromExtrInfo(extraInfo) {\n    if (!extraInfo || !extraInfo.headersText) return;\n    const firstLine = extraInfo.headersText.split('\\r', 1)[0];\n    if (!firstLine) return;\n    const match = firstLine.match(/[^ ]* [^ ]* (.*)/);\n    if (!match) return;\n    const statusText = match[1];\n    if (!statusText) return;\n    return statusText;\n  }\n  /**\n   * @internal\n   */\n\n\n  _resolveBody(err) {\n    return this._bodyLoadedPromiseFulfill(err);\n  }\n  /**\n   * @returns The IP address and port number used to connect to the remote\n   * server.\n   */\n\n\n  remoteAddress() {\n    return this._remoteAddress;\n  }\n  /**\n   * @returns The URL of the response.\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * @returns True if the response was successful (status in the range 200-299).\n   */\n\n\n  ok() {\n    // TODO: document === 0 case?\n    return this._status === 0 || this._status >= 200 && this._status <= 299;\n  }\n  /**\n   * @returns The status code of the response (e.g., 200 for a success).\n   */\n\n\n  status() {\n    return this._status;\n  }\n  /**\n   * @returns  The status text of the response (e.g. usually an \"OK\" for a\n   * success).\n   */\n\n\n  statusText() {\n    return this._statusText;\n  }\n  /**\n   * @returns An object with HTTP headers associated with the response. All\n   * header names are lower-case.\n   */\n\n\n  headers() {\n    return this._headers;\n  }\n  /**\n   * @returns {@link SecurityDetails} if the response was received over the\n   * secure connection, or `null` otherwise.\n   */\n\n\n  securityDetails() {\n    return this._securityDetails;\n  }\n  /**\n   * @returns Timing information related to the response.\n   */\n\n\n  timing() {\n    return this._timing;\n  }\n  /**\n   * @returns Promise which resolves to a buffer with response body.\n   */\n\n\n  buffer() {\n    if (!this._contentPromise) {\n      this._contentPromise = this._bodyLoadedPromise.then(async error => {\n        if (error) throw error;\n\n        try {\n          const response = await this._client.send('Network.getResponseBody', {\n            requestId: this._request._requestId\n          });\n          return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n        } catch (error) {\n          if (error instanceof Errors_js_1.ProtocolError && error.originalMessage === 'No resource with given identifier found') {\n            throw new Errors_js_1.ProtocolError('Could not load body for this request. This might happen if the request is a preflight request.');\n          }\n\n          throw error;\n        }\n      });\n    }\n\n    return this._contentPromise;\n  }\n  /**\n   * @returns Promise which resolves to a text representation of response body.\n   */\n\n\n  async text() {\n    const content = await this.buffer();\n    return content.toString('utf8');\n  }\n  /**\n   *\n   * @returns Promise which resolves to a JSON representation of response body.\n   *\n   * @remarks\n   *\n   * This method will throw if the response body is not parsable via\n   * `JSON.parse`.\n   */\n\n\n  async json() {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n  /**\n   * @returns A matching {@link HTTPRequest} object.\n   */\n\n\n  request() {\n    return this._request;\n  }\n  /**\n   * @returns True if the response was served from either the browser's disk\n   * cache or memory cache.\n   */\n\n\n  fromCache() {\n    return this._fromDiskCache || this._request._fromMemoryCache;\n  }\n  /**\n   * @returns True if the response was served by a service worker.\n   */\n\n\n  fromServiceWorker() {\n    return this._fromServiceWorker;\n  }\n  /**\n   * @returns A {@link Frame} that initiated this response, or `null` if\n   * navigating to error pages.\n   */\n\n\n  frame() {\n    return this._request.frame();\n  }\n\n}\n\nexports.HTTPResponse = HTTPResponse;","map":{"version":3,"mappings":"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","names":["HTTPResponse","constructor","client","request","responsePayload","extraInfo","_client","_request","_bodyLoadedPromise","Promise","fulfill","_bodyLoadedPromiseFulfill","_remoteAddress","ip","remoteIPAddress","port","remotePort","_statusText","_parseStatusTextFromExtrInfo","statusText","_url","url","_fromDiskCache","fromDiskCache","_fromServiceWorker","fromServiceWorker","_status","statusCode","status","headers","key","Object","keys","_headers","toLowerCase","_securityDetails","securityDetails","SecurityDetails_js_1","_timing","timing","headersText","firstLine","split","match","_resolveBody","err","remoteAddress","ok","buffer","_contentPromise","then","error","response","send","requestId","_requestId","Buffer","from","body","base64Encoded","Errors_js_1","originalMessage","text","content","toString","json","JSON","parse","fromCache","_fromMemoryCache","frame","exports"],"sources":["../../../../src/common/HTTPResponse.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}